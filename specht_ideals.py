from partitions import *
from expressions import *
import math
import sympy as sp
t = sp.symbols('t')

# hilbert series of I_mu, where mu is a partition
def specht_hilbert_series(mu: Partition):    
    recursive_partitions = PartitionSet([mu]) # this set holds the partitions that will be involved in the recursion
    new_partitions = PartitionSet([mu]) # this set holds the partitions that still need to be processed (we need to store the partitions that are involved with their Hilbert series)
    while len(new_partitions.partitions) != 0:
        p = new_partitions.partitions[0]
        for i in range(1, p.len() + 1):
            for g in lower_ideal_generators(p, i):
                success = recursive_partitions.add_partition(g)
                if success:
                    new_partitions.add_partition(g)
        new_partitions.remove_partition(p)

    hilbert_series = {} # this dictionary stores the hilbert series of all partitions in recursive_partitions
    for p in reversed(recursive_partitions.partitions):
        if p.len() == 1:
            hilbert_series[p] = HilbExpr(0)
            continue
        if p.parts[0] == 1:
            hilbert_series[p] = HilbExpr(1 - t**(math.comb(p.n, 2)), p.n, simplify=True)
            continue

        hs = HilbExpr(0)
        for i in range(1, p.len()):
            gens = lower_ideal_generators(p, i)
            if len(gens) == 1:
                hs += HilbExpr(t**(i - 1)) * hilbert_series[gens[0]]
            else:
                hs += HilbExpr(t**(i - 1)) * (hilbert_series[gens[0]] + hilbert_series[gens[1]] - hilbert_series[gens[2]])
        gens = lower_ideal_generators(p, p.len())
        if len(gens) == 1:
            hs += HilbExpr(t**(p.len() - 1), 1) * hilbert_series[gens[0]]
        else:
            hs += HilbExpr(t**(p.len() - 1), 1) * (hilbert_series[gens[0]] + hilbert_series[gens[1]] - hilbert_series[gens[2]])
        hilbert_series[p] = hs

    return hilbert_series[mu]

# hilbert series of I_L, where L is a lower order ideal
def ideal_specht_hilbert_series(L: LowerOrderIdeal):
    # base cases
    if len(L.generators) == 1:
        return specht_hilbert_series(L.generators[0])
    if len(L.partitions) == 0:
        return HilbExpr(1, L.n) 

    hs = HilbExpr(0)
    max_len = max([g.len() for g in L.generators])
    for i in range(max_len - 1):
        hs += HilbExpr(t**i)  * ideal_specht_hilbert_series(L.smaller_ideal(i + 1))
    hs += HilbExpr(t**(max_len - 1), 1) * ideal_specht_hilbert_series(L.smaller_ideal(max_len))
    return hs

# generators of L_i, where L is the lower order ideal generated by the partion mu
def lower_ideal_generators(mu: Partition, i):
    if mu.len() == 1 or mu.parts[0] == 1:
        return [] # these are base cases for the recursive formula, so we don't consider the generators

    corner_rows = [x[0] for x in mu.corner_set()]
    m = max((x for x in corner_rows if x <= i), default=0)
    ith_part = mu.parts[i - 1]

    if ith_part == 1:
        return [mu.remove_from_part(m)]
    
    gamma_parts = mu.parts[0: i]
    gamma_parts += ([ith_part - 1] * ((mu.sum() - sum(gamma_parts)) // (ith_part - 1)))
    if (mu.sum() - sum(gamma_parts)) % (ith_part - 1) != 0:
        gamma_parts.append((mu.sum() - sum(gamma_parts)) % (ith_part - 1))
    mu_meet_gamma = Partition(gamma_parts).meet(mu)
    
    if m == 0 or m == i:
        return [mu_meet_gamma.remove_from_part(i)]
    
    p1 = mu.remove_from_part(m)
    p2 = mu_meet_gamma.remove_from_part(i)
    return [p1, p2, p1.meet(p2)]

L = LowerOrderIdeal(10, [Partition([3, 3, 3, 1]), Partition([4, 2, 2, 2]), Partition([4, 3, 1, 1, 1])])
print(ideal_specht_hilbert_series(L))